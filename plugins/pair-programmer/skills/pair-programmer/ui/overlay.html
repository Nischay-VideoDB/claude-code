<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>VideoDB Context Overlay</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      background: transparent;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji';
    }
    .container {
      background: rgba(26, 26, 26, 0.95);
      border-radius: 12px;
      padding: 16px;
      color: #fff;
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      min-height: 120px;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      -webkit-app-region: drag;
    }
    .title {
      font-size: 13px;
      font-weight: 600;
      color: #f5f5f7;
    }
    .close-btn {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: none;
      background: #333;
      color: #999;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-app-region: no-drag;
    }
    .close-btn:hover {
      background: #444;
      color: #fff;
    }

    /* Main content area */
    .content {
      flex: 1;
      overflow-y: auto;
      font-size: 12px;
      line-height: 1.5;
      color: #ccc;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .content::-webkit-scrollbar { width: 6px; }
    .content::-webkit-scrollbar-track { background: transparent; }
    .content::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
    .content.hidden { display: none; }

    /* Loading / spinner overlay (used for assistant + starting) */
    .loading-wrap {
      display: none;
      flex: 1;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 24px 0;
    }
    .loading-wrap.visible { display: flex; }
    .spinner {
      width: 28px;
      height: 28px;
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-text {
      font-size: 12px;
      color: #86868b;
    }

    /* Status bar (bottom) */
    .status {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 11px;
      color: #86868b;
    }

    /* Status states ‚Äî all hidden by default, .visible to show */
    .status-idle,
    .status-starting,
    .status-recording,
    .status-stopping,
    .status-stopped,
    .status-exported,
    .status-failed { display: none; }

    .status-idle.visible,
    .status-starting.visible,
    .status-stopping.visible,
    .status-stopped.visible { display: block; }

    .status-recording.visible {
      display: flex;
      flex-wrap: wrap;
      gap: 10px 14px;
      align-items: center;
    }

    .status-failed.visible {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    /* Recording channels */
    .channel-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .status-dot {
      display: inline-block;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .status-dot.green { background: #30d158; }
    .status-dot.yellow { background: #ffd60a; }
    .status-dot.blue { background: #0a84ff; }
    .status-dot.red { background: #ff453a; }
    .status-dot.live {
      animation: blink 1.2s ease-in-out infinite;
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .status-duration {
      margin-left: auto;
      font-variant-numeric: tabular-nums;
      color: #aaa;
    }

    /* Visual latency indicator */
    .status-latency {
      display: none;
      width: 100%;
      margin-top: 6px;
      font-size: 10px;
      font-variant-numeric: tabular-nums;
      color: #86868b;
    }
    .status-latency.visible { display: flex; align-items: center; gap: 6px; }
    .latency-value { color: #aaa; }
    .latency-value.good { color: #30d158; }
    .latency-value.ok { color: #ffd60a; }
    .latency-value.slow { color: #ff9f0a; }
    .latency-value.bad { color: #ff453a; }
    .latency-waiting { color: #555; font-style: italic; }

    /* Starting */
    .status-starting {
      display: none;
      align-items: center;
      gap: 8px;
    }
    .status-starting.visible { display: flex; }
    .mini-spinner {
      width: 12px;
      height: 12px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-top-color: #ffd60a;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    /* Stopping */
    .status-stopping {
      display: none;
      align-items: center;
      gap: 8px;
    }
    .status-stopping.visible { display: flex; }

    /* Stopped */
    .status-stopped { color: #30d158; }

    /* Exported */
    .status-exported { color: #0a84ff; }
    .status-exported.visible {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .view-btn {
      background: #0a84ff;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 2px 8px;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      margin-left: 4px;
    }
    .view-btn:hover { background: #0077e6; }

    /* Failed */
    .status-failed-message { color: #ff453a; }
    .status-failed-hint { color: #86868b; font-size: 10px; }

    /* Context viewer */
    .context-viewer { display: none; flex: 1; flex-direction: column; overflow: hidden; }
    .context-viewer.visible { display: flex; }
    .context-tabs {
      display: flex;
      gap: 2px;
      margin-bottom: 8px;
      flex-shrink: 0;
    }
    .context-tab {
      padding: 4px 10px;
      font-size: 11px;
      border: none;
      border-radius: 6px;
      background: #2a2a2a;
      color: #86868b;
      cursor: pointer;
      -webkit-app-region: no-drag;
    }
    .context-tab:hover { background: #333; color: #ccc; }
    .context-tab.active { background: #444; color: #fff; }
    .context-list {
      flex: 1;
      overflow-y: auto;
      font-size: 11px;
      line-height: 1.5;
      color: #ccc;
    }
    .context-list::-webkit-scrollbar { width: 6px; }
    .context-list::-webkit-scrollbar-track { background: transparent; }
    .context-list::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
    .context-item {
      padding: 6px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .context-item:last-child { border-bottom: none; }
    .context-item-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 2px;
      font-size: 10px;
      color: #666;
    }
    .context-item-type {
      font-size: 10px;
      padding: 1px 5px;
      border-radius: 3px;
      background: #2a2a2a;
    }
    .context-item-type.screen { color: #0a84ff; }
    .context-item-type.mic { color: #30d158; }
    .context-item-type.system_audio { color: #ffd60a; }
    .context-item-text {
      font-size: 11px;
      color: #ccc;
      word-break: break-word;
    }
    .context-empty {
      color: #555;
      font-style: italic;
      padding: 16px 0;
      text-align: center;
    }
    .context-toggle {
      padding: 3px 8px;
      font-size: 11px;
      border: 1px solid #444;
      border-radius: 6px;
      background: transparent;
      color: #86868b;
      cursor: pointer;
      -webkit-app-region: no-drag;
    }
    .context-toggle:hover { background: #333; color: #ccc; }
    .context-toggle.active { background: #444; color: #fff; border-color: #666; }

    /* Permission prompt */
    .permission-prompt { display: none; flex: 1; flex-direction: column; gap: 12px; }
    .permission-prompt.visible { display: flex; }
    .permission-title {
      font-size: 13px;
      font-weight: 600;
      color: #ffd60a;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .permission-tool {
      font-size: 12px;
      color: #f5f5f7;
      padding: 8px 10px;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 8px;
      font-family: 'SF Mono', Menlo, Monaco, monospace;
    }
    .permission-input {
      font-size: 11px;
      color: #aaa;
      max-height: 120px;
      overflow-y: auto;
      padding: 8px 10px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      white-space: pre-wrap;
      word-break: break-all;
      font-family: 'SF Mono', Menlo, Monaco, monospace;
    }
    .permission-input::-webkit-scrollbar { width: 4px; }
    .permission-input::-webkit-scrollbar-thumb { background: #444; border-radius: 2px; }
    .permission-buttons {
      display: flex;
      gap: 8px;
      margin-top: 4px;
    }
    .permission-btn {
      flex: 1;
      padding: 8px 0;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      -webkit-app-region: no-drag;
    }
    .permission-btn.allow {
      background: #30d158;
      color: #000;
    }
    .permission-btn.allow:hover { background: #28b94c; }
    .permission-btn.deny {
      background: #ff453a;
      color: #fff;
    }
    .permission-btn.deny:hover { background: #e03e34; }

    /* Activity feed */
    .activity-feed {
      display: none;
      flex-direction: column;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      margin-top: 8px;
      padding-top: 6px;
      max-height: 140px;
      overflow-y: auto;
    }
    .activity-feed.visible { display: flex; }
    .activity-feed::-webkit-scrollbar { width: 4px; }
    .activity-feed::-webkit-scrollbar-track { background: transparent; }
    .activity-feed::-webkit-scrollbar-thumb { background: #333; border-radius: 2px; }

    .activity-feed-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 4px;
    }
    .activity-feed-title {
      font-size: 10px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .activity-feed-clear {
      font-size: 10px;
      color: #555;
      background: none;
      border: none;
      cursor: pointer;
      -webkit-app-region: no-drag;
    }
    .activity-feed-clear:hover { color: #999; }

    .activity-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 3px 0;
      font-size: 11px;
      color: #aaa;
    }
    .activity-icon {
      width: 14px;
      height: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      font-size: 10px;
    }
    .activity-icon .mini-spin {
      width: 10px;
      height: 10px;
      border: 1.5px solid rgba(255, 255, 255, 0.15);
      border-top-color: #0a84ff;
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
    }
    .activity-icon.done { color: #30d158; }
    .activity-icon.fail { color: #ff453a; }
    .activity-label {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-family: 'SF Mono', Menlo, Monaco, monospace;
      font-size: 10px;
    }
    .activity-tool-name {
      color: #ccc;
      font-weight: 600;
    }
    .activity-detail {
      color: #666;
      margin-left: 4px;
    }
    .activity-duration {
      flex-shrink: 0;
      font-size: 10px;
      font-variant-numeric: tabular-nums;
      color: #555;
    }

    /* MCP activity items */
    .activity-item.mcp-tool { border-left: 2px solid #bf5af2; padding-left: 6px; margin-left: 2px; }
    .activity-badge {
      display: inline-block;
      font-size: 8px;
      font-weight: 700;
      letter-spacing: 0.3px;
      padding: 1px 4px;
      border-radius: 3px;
      margin-right: 4px;
      vertical-align: middle;
      line-height: 1.4;
    }
    .activity-badge.mcp { background: rgba(191, 90, 242, 0.25); color: #bf5af2; }

    /* Subagent activity items */
    .activity-item.subagent {
      border-left: 2px solid #0a84ff;
      padding-left: 6px;
      margin-left: 2px;
    }
    .activity-item.subagent .activity-tool-name { color: #0a84ff; }
    .activity-item.subagent.agent-code-eye { border-left-color: #5e5ce6; }
    .activity-item.subagent.agent-code-eye .activity-tool-name { color: #5e5ce6; }
    .activity-item.subagent.agent-voice { border-left-color: #30d158; }
    .activity-item.subagent.agent-voice .activity-tool-name { color: #30d158; }
    .activity-item.subagent.agent-hearing { border-left-color: #ffd60a; }
    .activity-item.subagent.agent-hearing .activity-tool-name { color: #ffd60a; }

    /* Resize handle */
    .resize-handle {
      position: fixed;
      bottom: 0;
      right: 0;
      width: 16px;
      height: 16px;
      cursor: nwse-resize;
      -webkit-app-region: no-drag;
      z-index: 100;
    }
    .resize-handle::after {
      content: '';
      position: absolute;
      bottom: 3px;
      right: 3px;
      width: 8px;
      height: 8px;
      border-right: 2px solid rgba(255,255,255,0.25);
      border-bottom: 2px solid rgba(255,255,255,0.25);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <span class="title">üßû Pair Programmer</span>
      <div style="display:flex;gap:6px;align-items:center;-webkit-app-region:no-drag;">
        <button class="context-toggle" id="contextToggle" onclick="toggleContext()">Context</button>
        <button class="close-btn" onclick="closeOverlay()">√ó</button>
      </div>
    </div>

    <div class="loading-wrap" id="loadingWrap">
      <div class="spinner"></div>
      <span class="loading-text" id="loadingText">Thinking...</span>
    </div>

    <div class="content" id="content">
      Waiting for context...
    </div>

    <div class="permission-prompt" id="permissionPrompt">
      <div class="permission-title">üîê Permission Request</div>
      <div class="permission-tool" id="permissionTool"></div>
      <div class="permission-input" id="permissionInput"></div>
      <div class="permission-buttons">
        <button class="permission-btn allow" onclick="respondPermission('allow')">‚úì Allow</button>
        <button class="permission-btn deny" onclick="respondPermission('deny')">‚úï Deny</button>
      </div>
    </div>

    <div class="context-viewer" id="contextViewer">
      <div class="context-tabs">
        <button class="context-tab active" data-type="all" onclick="switchContextTab('all', this)">All</button>
        <button class="context-tab" data-type="screen" onclick="switchContextTab('screen', this)">üñ• Screen</button>
        <button class="context-tab" data-type="mic" onclick="switchContextTab('mic', this)">üéô Mic</button>
        <button class="context-tab" data-type="system_audio" onclick="switchContextTab('system_audio', this)">üîä Audio</button>
      </div>
      <div class="context-list" id="contextList">
        <div class="context-empty">No context yet</div>
      </div>
    </div>

    <div class="activity-feed" id="activityFeed">
      <div class="activity-feed-header">
        <span class="activity-feed-title">Activity</span>
        <button class="activity-feed-clear" onclick="clearActivityFeed()">clear</button>
      </div>
      <div id="activityList"></div>
    </div>

    <div class="status">
      <div class="status-idle visible" id="statusIdle">
        Type /record in Claude to start recording
      </div>
      <div class="status-starting" id="statusStarting">
        <div class="mini-spinner"></div>
        <span>Starting session...</span>
      </div>
      <div class="status-recording" id="statusRecording"></div>
      <div class="status-latency" id="statusLatency">
        <span>üñ• Latency:</span>
        <span class="latency-value" id="latencyValue">‚Äî</span>
      </div>
      <div class="status-stopping" id="statusStopping">
        <div class="mini-spinner"></div>
        <span>Stopping recording...</span>
      </div>
      <div class="status-stopped" id="statusStopped">
        ‚úì Recording saved
      </div>
      <div class="status-exported" id="statusExported">
        <span>‚úì Exported</span>
        <button class="view-btn" id="exportedViewBtn" style="display:none" onclick="openPlayerUrl()">View</button>
      </div>
      <div class="status-failed" id="statusFailed">
        <span class="status-failed-message" id="statusFailedMessage">Recording failed</span>
        <span class="status-failed-hint">Run /record again in Claude to start a new recording.</span>
      </div>
    </div>
  </div>

  <div class="resize-handle" id="resizeHandle"></div>

  <script>
    const { ipcRenderer, shell } = require('electron');

    let durationInterval = null;
    let recordingStartTime = null;
    let exportedTimeout = null;
    let currentPlayerUrl = null;

    // -- Content updates (from overlay-manager.show()) --
    ipcRenderer.on('overlay-content', (event, data) => {
      const loadingWrap = document.getElementById('loadingWrap');
      const content = document.getElementById('content');
      if (data.loading) {
        document.getElementById('loadingText').textContent = data.text || 'Thinking...';
        loadingWrap.classList.add('visible');
        content.classList.add('hidden');
      } else {
        loadingWrap.classList.remove('visible');
        content.classList.remove('hidden');
        content.textContent = data.text || 'No content';
        content.scrollTop = content.scrollHeight;
      }
    });

    // -- Status updates (from recording state changes) --
    ipcRenderer.on('overlay-status', (event, data) => {
      hideAllStatus();

      if (data.failed) {
        showStatus('statusFailed');
        document.getElementById('statusFailedMessage').textContent = data.failed.message || 'Recording failed';
      } else if (data.starting && !data.recording) {
        showStatus('statusStarting');
        showMainSpinner('Starting session...');
      } else if (data.recording && data.stopping) {
        showStatus('statusStopping');
      } else if (data.recording) {
        showStatus('statusRecording');
        renderChannels(data.channels, data.duration);
        startDurationTimer();
        hideMainSpinner();
        updateLatency(data.visualLatency);
      } else if (data.exported) {
        showStatus('statusExported');
        stopDurationTimer();
        currentPlayerUrl = (data.exported && data.exported.playerUrl) || null;
        var viewBtn = document.getElementById('exportedViewBtn');
        if (currentPlayerUrl) {
          viewBtn.style.display = '';
        } else {
          viewBtn.style.display = 'none';
        }
        // After 10s, transition to stopped
        if (exportedTimeout) clearTimeout(exportedTimeout);
        exportedTimeout = setTimeout(function() {
          hideAllStatus();
          showStatus('statusStopped');
          exportedTimeout = null;
        }, 10000);
      } else if (data.stopped) {
        showStatus('statusStopped');
        stopDurationTimer();
      } else {
        showStatus('statusIdle');
        stopDurationTimer();
        hideMainSpinner();
      }
    });

    function hideAllStatus() {
      ['statusIdle', 'statusStarting', 'statusRecording', 'statusStopping',
       'statusStopped', 'statusExported', 'statusFailed', 'statusLatency'].forEach(function(id) {
        document.getElementById(id).classList.remove('visible');
      });
    }

    function showStatus(id) {
      document.getElementById(id).classList.add('visible');
    }

    function showMainSpinner(text) {
      document.getElementById('loadingText').textContent = text;
      document.getElementById('loadingWrap').classList.add('visible');
      document.getElementById('content').classList.add('hidden');
    }

    function hideMainSpinner() {
      document.getElementById('loadingWrap').classList.remove('visible');
      document.getElementById('content').classList.remove('hidden');
    }

    function channelEmoji(name) {
      var n = name.toLowerCase();
      if (n.includes('display') || n.includes('screen')) return 'üñ•';
      if (n.includes('mic')) return 'üéô';
      if (n.includes('system') || n.includes('audio')) return 'üîä';
      return 'üì°';
    }

    function renderChannels(channels, duration) {
      const el = document.getElementById('statusRecording');
      const names = (channels && channels.length) ? channels : ['Recording'];
      let html = names.map(function(name) {
        return '<div class="channel-item"><span class="status-dot green live"></span><span>' + channelEmoji(name) + ' ' + name + '</span></div>';
      }).join('');
      html += '<span class="status-duration" id="durationLabel">' + formatDuration(duration || 0) + '</span>';
      el.innerHTML = html;
    }

    function startDurationTimer() {
      stopDurationTimer();
      recordingStartTime = Date.now();
      durationInterval = setInterval(function() {
        const label = document.getElementById('durationLabel');
        if (!label) return;
        const el = document.getElementById('statusRecording');
        if (!el.classList.contains('visible')) return;
        // Read current text, parse and increment locally for smooth updates
        const elapsed = Math.round((Date.now() - recordingStartTime) / 1000);
        // We don't know the absolute start, so just update from the initial duration
        label.textContent = formatDuration(elapsed + (window._baseDuration || 0));
      }, 1000);
    }

    function stopDurationTimer() {
      if (durationInterval) {
        clearInterval(durationInterval);
        durationInterval = null;
      }
      recordingStartTime = null;
    }

    function formatDuration(totalSeconds) {
      var mins = Math.floor(totalSeconds / 60);
      var secs = totalSeconds % 60;
      return mins + ':' + (secs < 10 ? '0' : '') + secs;
    }

    // Store base duration from first status update so local timer can increment from it
    ipcRenderer.on('overlay-status', (event, data) => {
      if (data.recording && !data.stopping && data.duration != null) {
        window._baseDuration = data.duration;
        recordingStartTime = Date.now();
      }
    });

    function updateLatency(latencyMs) {
      var el = document.getElementById('statusLatency');
      var val = document.getElementById('latencyValue');
      el.classList.add('visible');

      if (latencyMs == null) {
        val.textContent = 'waiting...';
        val.className = 'latency-value latency-waiting';
        return;
      }

      val.className = 'latency-value';
      if (latencyMs < 100) {
        val.textContent = '<100ms';
        val.classList.add('good');
      } else {
        var secs = (latencyMs / 1000).toFixed(2);
        val.textContent = secs + 's';
        if (latencyMs < 5000) val.classList.add('good');
        else if (latencyMs < 10000) val.classList.add('ok');
        else if (latencyMs < 20000) val.classList.add('slow');
        else val.classList.add('bad');
      }
    }

    // -- Context viewer --
    var contextOpen = false;
    var contextTab = 'all';
    var contextRefreshInterval = null;

    function toggleContext() {
      contextOpen = !contextOpen;
      var viewer = document.getElementById('contextViewer');
      var content = document.getElementById('content');
      var loadingWrap = document.getElementById('loadingWrap');
      var toggle = document.getElementById('contextToggle');

      if (contextOpen) {
        viewer.classList.add('visible');
        content.classList.add('hidden');
        loadingWrap.classList.remove('visible');
        toggle.classList.add('active');
        fetchContext();
        contextRefreshInterval = setInterval(fetchContext, 3000);
      } else {
        viewer.classList.remove('visible');
        content.classList.remove('hidden');
        toggle.classList.remove('active');
        if (contextRefreshInterval) {
          clearInterval(contextRefreshInterval);
          contextRefreshInterval = null;
        }
      }
    }

    function switchContextTab(type, btn) {
      contextTab = type;
      document.querySelectorAll('.context-tab').forEach(function(t) { t.classList.remove('active'); });
      btn.classList.add('active');
      fetchContext();
    }

    async function fetchContext() {
      try {
        var data = await ipcRenderer.invoke('get-context', contextTab === 'all' ? 'all' : contextTab);
        renderContext(data);
      } catch (e) {
        document.getElementById('contextList').innerHTML = '<div class="context-empty">Failed to load context</div>';
      }
    }

    function renderContext(data) {
      var list = document.getElementById('contextList');
      var items = [];

      if (contextTab === 'all') {
        ['screen', 'mic', 'system_audio'].forEach(function(type) {
          (data[type] || []).forEach(function(item) {
            items.push({ type: type, text: item.text, timestamp: item.timestamp });
          });
        });
        items.sort(function(a, b) { return (a.timestamp || '').localeCompare(b.timestamp || ''); });
      } else {
        var arr = data[contextTab] || [];
        items = arr.map(function(item) {
          return { type: contextTab, text: item.text, timestamp: item.timestamp };
        });
      }

      if (items.length === 0) {
        list.innerHTML = '<div class="context-empty">No context yet</div>';
        return;
      }

      var typeEmoji = { screen: 'üñ•', mic: 'üéô', system_audio: 'üîä' };
      var html = items.map(function(item) {
        var time = item.timestamp ? new Date(item.timestamp).toLocaleTimeString() : '';
        var emoji = typeEmoji[item.type] || 'üì°';
        return '<div class="context-item">' +
          '<div class="context-item-header">' +
            '<span class="context-item-type ' + item.type + '">' + emoji + ' ' + item.type.replace('_', ' ') + '</span>' +
            '<span>' + time + '</span>' +
          '</div>' +
          '<div class="context-item-text">' + escapeHtml(item.text || '(empty)') + '</div>' +
        '</div>';
      }).join('');

      var wasAtBottom = list.scrollHeight - list.scrollTop - list.clientHeight < 30;
      list.innerHTML = html;
      if (wasAtBottom) list.scrollTop = list.scrollHeight;
    }

    function escapeHtml(str) {
      var div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    // Resize handle drag
    (function() {
      const handle = document.getElementById('resizeHandle');
      let startX, startY, startW, startH;
      handle.addEventListener('mousedown', function(e) {
        e.preventDefault();
        startX = e.screenX;
        startY = e.screenY;
        startW = window.outerWidth;
        startH = window.outerHeight;
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
      });
      function onMove(e) {
        var w = Math.max(250, startW + (e.screenX - startX));
        var h = Math.max(150, startH + (e.screenY - startY));
        ipcRenderer.send('overlay-resize', { width: w, height: h });
      }
      function onUp() {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
      }
    })();

    function openPlayerUrl() {
      if (currentPlayerUrl) shell.openExternal(currentPlayerUrl);
    }

    // -- Permission prompt --
    ipcRenderer.on('permission-prompt', (event, data) => {
      // Hide content/loading, show permission prompt
      document.getElementById('loadingWrap').classList.remove('visible');
      document.getElementById('content').classList.add('hidden');
      document.getElementById('contextViewer').classList.remove('visible');

      var prompt = document.getElementById('permissionPrompt');
      document.getElementById('permissionTool').textContent = data.toolName || 'Unknown tool';
      var inputStr = typeof data.toolInput === 'string'
        ? data.toolInput
        : JSON.stringify(data.toolInput, null, 2);
      document.getElementById('permissionInput').textContent = inputStr || '(no input)';
      prompt.classList.add('visible');
    });

    function respondPermission(decision) {
      ipcRenderer.send('permission-response', decision);
      // Hide prompt, restore content
      document.getElementById('permissionPrompt').classList.remove('visible');
      document.getElementById('content').classList.remove('hidden');
      document.getElementById('content').textContent = decision === 'allow'
        ? '‚úì Permission allowed'
        : '‚úï Permission denied';
    }

    // -- Activity feed --
    var activityItems = {};  // seq ‚Üí { toolName, start, timer }
    var activitySeq = 0;
    var pendingTools = {};   // tool_name ‚Üí [seq, seq, ...] (FIFO queue for parallel calls)

    ipcRenderer.on('hook-event', (event, data) => {
      var feed = document.getElementById('activityFeed');
      var list = document.getElementById('activityList');

      if (data.event === 'PreToolUse') {
        activitySeq++;
        var seq = activitySeq;
        var toolName = data.tool_name || 'unknown';
        var detail = summarizeInput(toolName, data.tool_input);
        if (!pendingTools[toolName]) pendingTools[toolName] = [];
        pendingTools[toolName].push(seq);
        activityItems[seq] = { toolName: toolName, start: Date.now() };

        var el = document.createElement('div');
        el.className = 'activity-item' + (isMcpTool(toolName) ? ' mcp-tool' : '');
        el.id = 'activity-' + seq;
        el.innerHTML =
          '<div class="activity-icon"><div class="mini-spin"></div></div>' +
          '<div class="activity-label"><span class="activity-tool-name">' + prettifyToolName(toolName) + '</span>' +
          '<span class="activity-detail">' + escapeHtml(detail) + '</span></div>' +
          '<span class="activity-duration" id="activity-dur-' + seq + '"></span>';
        list.appendChild(el);
        feed.classList.add('visible');
        feed.scrollTop = feed.scrollHeight;

        // Live duration counter
        activityItems[seq].timer = setInterval(function() {
          var durEl = document.getElementById('activity-dur-' + seq);
          if (!durEl) return;
          var elapsed = ((Date.now() - activityItems[seq].start) / 1000).toFixed(1);
          durEl.textContent = elapsed + 's';
        }, 200);
      }

      if (data.event === 'PostToolUse' || data.event === 'PostToolUseFailure') {
        var toolName = data.tool_name || 'unknown';
        var queue = pendingTools[toolName];
        var seq = queue && queue.length > 0 ? queue.shift() : null;
        if (seq && activityItems[seq]) {
          var item = activityItems[seq];
          if (item.timer) clearInterval(item.timer);
          var elapsed = ((Date.now() - item.start) / 1000).toFixed(1);
          var el = document.getElementById('activity-' + seq);
          if (el) {
            var icon = el.querySelector('.activity-icon');
            if (data.event === 'PostToolUse') {
              icon.innerHTML = '‚úì';
              icon.className = 'activity-icon done';
            } else {
              icon.innerHTML = '‚úó';
              icon.className = 'activity-icon fail';
            }
            var durEl = document.getElementById('activity-dur-' + seq);
            if (durEl) durEl.textContent = elapsed + 's';
          }
          if (queue && queue.length === 0) delete pendingTools[toolName];
        }
      }

      if (data.event === 'Stop') {
        // Clear all pending spinners (pendingTools values are now arrays)
        Object.keys(pendingTools).forEach(function(k) {
          var queue = pendingTools[k];
          if (!Array.isArray(queue)) queue = [queue];
          queue.forEach(function(s) {
            if (activityItems[s] && activityItems[s].timer) clearInterval(activityItems[s].timer);
            var el = document.getElementById('activity-' + s);
            if (el) {
              var icon = el.querySelector('.activity-icon');
              icon.innerHTML = '‚óè';
              icon.className = 'activity-icon done';
            }
          });
        });
        pendingTools = {};
      }

      if (data.event === 'SubagentStart') {
        activitySeq++;
        var seq = activitySeq;
        var agentType = data.agent_type || 'unknown';
        var agentLabel = { 'code-eye': 'code-eye', 'voice': 'voice', 'hearing': 'hearing' }[agentType] || agentType;
        var agentIcon = { 'code-eye': 'üëÅ', 'voice': 'üé§', 'hearing': 'üîä' }[agentType] || '‚ö°';
        var agentClass = 'agent-' + agentType;
        var agentKey = '_agent_' + agentType;
        if (!pendingTools[agentKey]) pendingTools[agentKey] = [];
        pendingTools[agentKey].push(seq);
        activityItems[seq] = { toolName: agentType, start: Date.now() };

        var el = document.createElement('div');
        el.className = 'activity-item subagent ' + agentClass;
        el.id = 'activity-' + seq;
        el.innerHTML =
          '<div class="activity-icon">' + agentIcon + '</div>' +
          '<div class="activity-label"><span class="activity-tool-name">' + escapeHtml(agentLabel) + '</span>' +
          '<span class="activity-detail">analyzing...</span></div>' +
          '<span class="activity-duration" id="activity-dur-' + seq + '"></span>';
        list.appendChild(el);
        feed.classList.add('visible');
        feed.scrollTop = feed.scrollHeight;

        activityItems[seq].timer = setInterval(function() {
          var durEl = document.getElementById('activity-dur-' + seq);
          if (!durEl) return;
          var elapsed = ((Date.now() - activityItems[seq].start) / 1000).toFixed(1);
          durEl.textContent = elapsed + 's';
        }, 200);
      }

      if (data.event === 'SubagentStop') {
        var agentType = data.agent_type || 'unknown';
        var agentKey = '_agent_' + agentType;
        var queue = pendingTools[agentKey];
        var seq = queue && queue.length > 0 ? queue.shift() : null;
        if (seq && activityItems[seq]) {
          var item = activityItems[seq];
          if (item.timer) clearInterval(item.timer);
          var elapsed = ((Date.now() - item.start) / 1000).toFixed(1);
          var el = document.getElementById('activity-' + seq);
          if (el) {
            var detail = el.querySelector('.activity-detail');
            if (detail) detail.textContent = 'done';
            var icon = el.querySelector('.activity-icon');
            if (icon) icon.className = 'activity-icon done';
            var durEl = document.getElementById('activity-dur-' + seq);
            if (durEl) durEl.textContent = elapsed + 's';
          }
          if (queue && queue.length === 0) delete pendingTools[agentKey];
        }
      }

      if (data.event === 'Notification' && data.message) {
        activitySeq++;
        var el = document.createElement('div');
        el.className = 'activity-item';
        el.innerHTML =
          '<div class="activity-icon" style="color:#ffd60a;">!</div>' +
          '<div class="activity-label"><span class="activity-detail">' + escapeHtml(data.message) + '</span></div>';
        list.appendChild(el);
        feed.classList.add('visible');
        feed.scrollTop = feed.scrollHeight;
      }
    });

    function isMcpTool(toolName) {
      return toolName && toolName.startsWith('mcp__') && toolName.indexOf('__', 5) !== -1;
    }

    function mcpToolShortName(toolName) {
      var lastSep = toolName.lastIndexOf('__');
      return lastSep > 4 ? toolName.substring(lastSep + 2) : toolName;
    }

    function prettifyToolName(toolName) {
      if (!isMcpTool(toolName)) return escapeHtml(toolName);
      var short = mcpToolShortName(toolName);
      var label = short.replace(/_/g, ' ').replace(/\b\w/g, function(c) { return c.toUpperCase(); });
      return '<span class="activity-badge mcp">MCP</span>' + escapeHtml(label);
    }

    function summarizeMcpInput(shortName, input) {
      switch (shortName) {
        case 'get_context':
          return input.context_type ? input.context_type : '';
        case 'show_overlay':
          if (input.loading) return 'loading...';
          if (input.text) {
            var t = input.text;
            return t.length > 50 ? t.substring(0, 47) + '...' : t;
          }
          return '';
        case 'hide_overlay':
          return '';
        case 'search_rtstream':
          return input.query ? '"' + (input.query.length > 40 ? input.query.substring(0, 37) + '...' : input.query) + '"' : '';
        case 'update_prompt':
          return input.stream_id ? 'stream: ' + input.stream_id : '';
        case 'get_status':
          return '';
        case 'record_start':
          return input.channels ? input.channels : '';
        case 'record_stop':
          return '';
        default:
          return '';
      }
    }

    function summarizeInput(toolName, rawInput) {
      try {
        var input = typeof rawInput === 'string' ? JSON.parse(rawInput) : rawInput;
        if (!input) return '';
        if (isMcpTool(toolName)) return summarizeMcpInput(mcpToolShortName(toolName), input);
        if (toolName === 'Read' && input.file_path) return input.file_path;
        if (toolName === 'Write' && input.file_path) return input.file_path;
        if (toolName === 'Edit' && input.file_path) return input.file_path;
        if (toolName === 'Bash' && input.command) {
          var cmd = input.command;
          return cmd.length > 60 ? cmd.substring(0, 57) + '...' : cmd;
        }
        if (toolName === 'Grep' && input.pattern) return input.pattern;
        if (toolName === 'Glob' && input.pattern) return input.pattern;
        if (toolName === 'Task' && input.description) return input.description;
        if (toolName === 'Task' && input.agent_type) return input.agent_type;
        var keys = Object.keys(input);
        if (keys.length > 0) {
          var val = String(input[keys[0]]);
          return val.length > 50 ? val.substring(0, 47) + '...' : val;
        }
      } catch (e) {}
      return '';
    }

    function clearActivityFeed() {
      Object.keys(activityItems).forEach(function(k) {
        if (activityItems[k].timer) clearInterval(activityItems[k].timer);
      });
      activityItems = {};
      pendingTools = {};
      activitySeq = 0;
      document.getElementById('activityList').innerHTML = '';
      document.getElementById('activityFeed').classList.remove('visible');
    }

    function closeOverlay() {
      ipcRenderer.send('overlay-close');
    }
  </script>
</body>
</html>
